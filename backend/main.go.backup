package main

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"html"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
)

type ReceivedMessage struct {
	Timestamp time.Time `json:"timestamp"`
	UserID    string    `json:"userID"`
	Text      string    `json:"text"`
}

var messages []ReceivedMessage
var db *sql.DB

// LINE Webhookç”¨æ§‹é€ ä½“
type WebhookRequest struct {
	Events []WebhookEvent `json:"events"`
}

type WebhookEvent struct {
	Type       string  `json:"type"`
	ReplyToken string  `json:"replyToken"`
	Message    Message `json:"message"`
	Source     Source  `json:"source"`
}

type Message struct {
	Type string `json:"type"`
	Text string `json:"text"`
}

type Source struct {
	UserID string `json:"userId"`
}

// LINE Push APIç”¨æ§‹é€ ä½“
type PushRequest struct {
	To       string `json:"to"`
	Messages []struct {
		Type string `json:"type"`
		Text string `json:"text"`
	} `json:"messages"`
}

// LINE Reply APIç”¨æ§‹é€ ä½“
type ReplyRequest struct {
	ReplyToken string `json:"replyToken"`
	Messages   []struct {
		Type string `json:"type"`
		Text string `json:"text"`
	} `json:"messages"`
}

// ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’ç®¡ç†ã™ã‚‹æ§‹é€ ä½“
type User struct {
	UserID          string
	Name            string
	Circle          string
	Step            int //0,æœªç™»éŒ²ã€€1,åå‰å¾…ã¡ã€€2,ã‚µãƒ¼ã‚¯ãƒ«åå‰å¾…ã¡ 3,å®Œäº†
	SplitEventStep  int // 0:ãªã— 1:ã‚¤ãƒ™ãƒ³ãƒˆåå¾…ã¡ 2:é‡‘é¡å¾…ã¡ 3:å‚åŠ è€…é¸æŠå¾…ã¡
	TempEventID     int // ä½œæˆä¸­ã®ã‚¤ãƒ™ãƒ³ãƒˆID
	ApprovalStep    int // 0:ãªã— 1:æ‰¿èªç•ªå·å¾…ã¡
	ApprovalEventID int // æ‰¿èªä¸­ã®ã‚¤ãƒ™ãƒ³ãƒˆID
}

// å‰²ã‚Šå‹˜ã‚¤ãƒ™ãƒ³ãƒˆæƒ…å ±ã‚’ç®¡ç†ã™ã‚‹æ§‹é€ ä½“
type Event struct {
	ID           int
	EventName    string
	OrganizerID  string
	Circle       string
	TotalAmount  int
	SplitAmount  int
	Status       string // 'selecting' / 'confirmed' / 'completed'
	CreatedAt    time.Time
	UpdatedAt    time.Time
}

// ã‚¤ãƒ™ãƒ³ãƒˆå‚åŠ è€…æƒ…å ±ã‚’ç®¡ç†ã™ã‚‹æ§‹é€ ä½“
type Participant struct {
	ID         int
	EventID    int
	UserID     string
	UserName   string
	Paid       bool
	ReportedAt *time.Time
	PaidAt     *time.Time
	CreatedAt  time.Time
}

var users = make(map[string]*User)

// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–
func initDB() error { //errorå‹ã¯
	var err error
	databaseURL := os.Getenv("DATABASE_URL")
	if databaseURL == ""{
		return fmt.Errorf("DATABASE_URL is not set")
	}

	db, err = sql.Open("postgres", databaseURL)
	if err != nil{
		return fmt.Errorf("failed to open database")
	}

	// æ¥ç¶šç¢ºèª
	if err = db.Ping(); err != nil {
		return fmt.Errorf("failed to ping database: %w", err) //`%wã®æ„å‘³ã‚’æ¢ã‚‹`
	}

	log.Println("Database connected successfully")
	return nil
}

//ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ
func createTables() error{
	usersTable := `
	CREATE TABLE IF NOT EXISTS users (
	user_id TEXT PRIMARY KEY,
	name TEXT,
	circle TEXT,
	step INTEGER NOT NULL,
	split_event_step INTEGER DEFAULT 0,
	temp_event_id INTEGER,
	approval_step INTEGER DEFAULT 0,
	approval_event_id INTEGER,
	created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);`

	messagesTable := `
	CREATE TABLE IF NOT EXISTS messages(
	id SERIAL PRIMARY KEY,
	user_id TEXT NOT NULL,
	text TEXT NOT NULL,
	timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);`

	eventsTable := `
	CREATE TABLE IF NOT EXISTS events (
	id SERIAL PRIMARY KEY,
	event_name TEXT NOT NULL,
	organizer_id TEXT NOT NULL,
	circle TEXT NOT NULL,
	total_amount INTEGER NOT NULL,
	split_amount INTEGER NOT NULL,
	status TEXT NOT NULL,
	created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);`

	participantsTable := `
	CREATE TABLE IF NOT EXISTS event_participants (
	id SERIAL PRIMARY KEY,
	event_id INTEGER NOT NULL REFERENCES events(id),
	user_id TEXT NOT NULL,
	user_name TEXT NOT NULL,
	paid BOOLEAN DEFAULT FALSE,
	reported_at TIMESTAMP,
	paid_at TIMESTAMP,
	created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);`

	indexEvents := `
	CREATE INDEX IF NOT EXISTS idx_events_organizer ON events(organizer_id);
	CREATE INDEX IF NOT EXISTS idx_events_circle ON events(circle);`

	indexParticipants := `
	CREATE INDEX IF NOT EXISTS idx_participants_event ON event_participants(event_id);
	CREATE INDEX IF NOT EXISTS idx_participants_user ON event_participants(user_id);`

	if _, err :=db.Exec(usersTable); err != nil{
		return fmt.Errorf("failed to create a user table: %w", err)
	}

	if _, err :=db.Exec(messagesTable) ; err != nil{
		return fmt.Errorf("failed to create a messages table: %w", err)
	}

	if _, err :=db.Exec(eventsTable); err != nil{
		return fmt.Errorf("failed to create events table: %w", err)
	}

	if _, err :=db.Exec(participantsTable); err != nil{
		return fmt.Errorf("failed to create event_participants table: %w", err)
	}

	if _, err :=db.Exec(indexEvents); err != nil{
		return fmt.Errorf("failed to create events indexes: %w", err)
	}

	if _, err :=db.Exec(indexParticipants); err != nil{
		return fmt.Errorf("failed to create participants indexes: %w", err)
	}

	// æ—¢å­˜ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã«æ–°ã—ã„ã‚«ãƒ©ãƒ ã‚’è¿½åŠ ï¼ˆã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼‰
	db.Exec(`ALTER TABLE users ADD COLUMN IF NOT EXISTS split_event_step INTEGER DEFAULT 0`)
	db.Exec(`ALTER TABLE users ADD COLUMN IF NOT EXISTS temp_event_id INTEGER`)
	db.Exec(`ALTER TABLE users ADD COLUMN IF NOT EXISTS approval_step INTEGER DEFAULT 0`)
	db.Exec(`ALTER TABLE users ADD COLUMN IF NOT EXISTS approval_event_id INTEGER`)
	db.Exec(`ALTER TABLE event_participants ADD COLUMN IF NOT EXISTS reported_at TIMESTAMP`)

	log.Println("Tables created successfully")
	return nil
}

// ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’DBã‹ã‚‰å–å¾—
func getUser(userID string) (*User, error) {
	user := &User{}
	err := db.QueryRow(`
		SELECT user_id, name, circle, step,
		       COALESCE(split_event_step, 0), COALESCE(temp_event_id, 0)
		FROM users
		WHERE user_id = $1
	`, userID).Scan(&user.UserID, &user.Name, &user.Circle, &user.Step,
		&user.SplitEventStep, &user.TempEventID)

	if err == sql.ErrNoRows {
		return nil, nil // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã—ãªã„ nil, nilã£ã¦ã©ã†ã‚†ã†æ§‹é€ ãªã‚“ã‚„
	}
	if err != nil {
		return nil, err
	}
	return user, nil
}

// ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’DBã«ä¿å­˜
func saveUser(user *User) error {
	_, err := db.Exec(`
		INSERT INTO users (user_id, name, circle, step, split_event_step, temp_event_id, approval_step, approval_event_id)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
	`, user.UserID, user.Name, user.Circle, user.Step, user.SplitEventStep, user.TempEventID, user.ApprovalStep, user.ApprovalEventID)
	return err
}

// ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’DBã§æ›´æ–°
func updateUser(user *User) error {
	_, err := db.Exec(`
		UPDATE users
		SET name = $2, circle = $3, step = $4, split_event_step = $5, temp_event_id = $6, approval_step = $7, approval_event_id = $8, updated_at = CURRENT_TIMESTAMP
		WHERE user_id = $1
	`, user.UserID, user.Name, user.Circle, user.Step, user.SplitEventStep, user.TempEventID, user.ApprovalStep, user.ApprovalEventID)
	return err
}

// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’DBã«ä¿å­˜
func saveMessage(userID, text string) error {
	_, err := db.Exec(`
		INSERT INTO messages (user_id, text)
		VALUES ($1, $2)
	`, userID, text)
	return err
}

// ===== å‰²ã‚Šå‹˜é–¢é€£ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œé–¢æ•° =====

// ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆ
func createEvent(organizerID, eventName, circle string, totalAmount, splitAmount int) (int, error) {
	var eventID int
	err := db.QueryRow(`
		INSERT INTO events (event_name, organizer_id, circle, total_amount, split_amount, status)
		VALUES ($1, $2, $3, $4, $5, 'selecting')
		RETURNING id
	`, eventName, organizerID, circle, totalAmount, splitAmount).Scan(&eventID)

	if err != nil {
		return 0, fmt.Errorf("failed to create event: %w", err)
	}
	return eventID, nil
}

// ã‚¤ãƒ™ãƒ³ãƒˆæƒ…å ±ã‚’å–å¾—
func getEvent(eventID int) (*Event, error) {
	event := &Event{}
	err := db.QueryRow(`
		SELECT id, event_name, organizer_id, circle, total_amount, split_amount, status, created_at, updated_at
		FROM events
		WHERE id = $1
	`, eventID).Scan(&event.ID, &event.EventName, &event.OrganizerID, &event.Circle,
		&event.TotalAmount, &event.SplitAmount, &event.Status, &event.CreatedAt, &event.UpdatedAt)

	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get event: %w", err)
	}
	return event, nil
}

// ã‚µãƒ¼ã‚¯ãƒ«å†…ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ã‚’å–å¾—
func getUsersByCircle(circle string) ([]User, error) {
	rows, err := db.Query(`
		SELECT user_id, name, circle, step, COALESCE(split_event_step, 0), COALESCE(temp_event_id, 0)
		FROM users
		WHERE circle = $1 AND step = 3
		ORDER BY name
	`, circle)
	if err != nil {
		return nil, fmt.Errorf("failed to get users by circle: %w", err)
	}
	defer rows.Close()

	var users []User
	for rows.Next() {
		var user User
		if err := rows.Scan(&user.UserID, &user.Name, &user.Circle, &user.Step,
			&user.SplitEventStep, &user.TempEventID); err != nil {
			log.Printf("ã‚¹ã‚­ãƒ£ãƒ³ã‚¨ãƒ©ãƒ¼: %v", err)
			continue
		}
		users = append(users, user)
	}
	return users, nil
}

// å‚åŠ è€…ã‚’è¿½åŠ 
func addParticipant(eventID int, userID, userName string) error {
	_, err := db.Exec(`
		INSERT INTO event_participants (event_id, user_id, user_name)
		VALUES ($1, $2, $3)
	`, eventID, userID, userName)

	if err != nil {
		return fmt.Errorf("failed to add participant: %w", err)
	}
	return nil
}

// ã‚¤ãƒ™ãƒ³ãƒˆã®å‚åŠ è€…ä¸€è¦§ã‚’å–å¾—
func getParticipants(eventID int) ([]Participant, error) {
	rows, err := db.Query(`
		SELECT id, event_id, user_id, user_name, paid, reported_at, paid_at, created_at
		FROM event_participants
		WHERE event_id = $1
		ORDER BY created_at
	`, eventID)
	if err != nil {
		return nil, fmt.Errorf("failed to get participants: %w", err)
	}
	defer rows.Close()

	var participants []Participant
	for rows.Next() {
		var p Participant
		if err := rows.Scan(&p.ID, &p.EventID, &p.UserID, &p.UserName, &p.Paid, &p.ReportedAt, &p.PaidAt, &p.CreatedAt); err != nil {
			log.Printf("ã‚¹ã‚­ãƒ£ãƒ³ã‚¨ãƒ©ãƒ¼: %v", err)
			continue
		}
		participants = append(participants, p)
	}
	return participants, nil
}

// æ”¯æ‰•ã„å ±å‘Šã‚’è¨˜éŒ²ï¼ˆä¼šè¨ˆæ‹…å½“è€…ã®æ‰¿èªå¾…ã¡ï¼‰
func markAsReported(eventID int, userID string) error {
	result, err := db.Exec(`
		UPDATE event_participants
		SET reported_at = CURRENT_TIMESTAMP
		WHERE event_id = $1 AND user_id = $2
	`, eventID, userID)

	if err != nil {
		return fmt.Errorf("failed to mark as reported: %w", err)
	}

	rows, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if rows == 0 {
		return fmt.Errorf("participant not found")
	}

	return nil
}

// æ”¯æ‰•ã„ã‚’æ‰¿èªï¼ˆä¼šè¨ˆæ‹…å½“è€…ãŒç¢ºèªå¾Œï¼‰
func approvePayment(eventID int, userID string) error {
	result, err := db.Exec(`
		UPDATE event_participants
		SET paid = TRUE, paid_at = CURRENT_TIMESTAMP
		WHERE event_id = $1 AND user_id = $2 AND reported_at IS NOT NULL
	`, eventID, userID)

	if err != nil {
		return fmt.Errorf("failed to approve payment: %w", err)
	}

	rows, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if rows == 0 {
		return fmt.Errorf("participant not found or not reported yet")
	}

	return nil
}

// ã‚¤ãƒ™ãƒ³ãƒˆã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°
func updateEventStatus(eventID int, status string) error {
	_, err := db.Exec(`
		UPDATE events
		SET status = $2, updated_at = CURRENT_TIMESTAMP
		WHERE id = $1
	`, eventID, status)

	if err != nil {
		return fmt.Errorf("failed to update event status: %w", err)
	}
	return nil
}

// ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå‚åŠ ã—ã¦ã„ã‚‹æœªå®Œäº†ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’å–å¾—ï¼ˆæœªæ‰•ã„ã¾ãŸã¯å ±å‘Šæ¸ˆã¿ï¼‰
func getUserActiveEvent(userID string) (*Event, error) {
	event := &Event{}
	err := db.QueryRow(`
		SELECT e.id, e.event_name, e.organizer_id, e.circle, e.total_amount, e.split_amount, e.status, e.created_at, e.updated_at
		FROM events e
		JOIN event_participants p ON e.id = p.event_id
		WHERE p.user_id = $1 AND p.paid = FALSE AND p.reported_at IS NULL
		ORDER BY e.created_at DESC
		LIMIT 1
	`, userID).Scan(&event.ID, &event.EventName, &event.OrganizerID, &event.Circle,
		&event.TotalAmount, &event.SplitAmount, &event.Status, &event.CreatedAt, &event.UpdatedAt)

	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get user active event: %w", err)
	}
	return event, nil
}

// LINE Reply APIå‘¼ã³å‡ºã—
func ReplyMessage(replyToken, text string) error {
	url := "https://api.line.me/v2/bot/message/reply"

	payload := ReplyRequest{
		ReplyToken: replyToken,
		Messages: []struct {
			Type string `json:"type"`
			Text string `json:"text"`
		}{
			{Type: "text", Text: text},
		},
	}

	jsonData, _ := json.Marshal(payload)
	req, _ := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+os.Getenv("LINE_CHANNEL_ACCESS_TOKEN"))

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("LINE API error: %s", string(body))
	}
	return nil
}

// LINE Push APIå‘¼ã³å‡ºã—
func PushMessage(userID, text string) error {
	url := "https://api.line.me/v2/bot/message/push"

	payload := PushRequest{
		To: userID,
		Messages: []struct {
			Type string `json:"type"`
			Text string `json:"text"`
		}{
			{Type: "text", Text: text},
		},
	}

	jsonData, err := json.Marshal(payload)
	if err != nil {
		return err
	}
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+os.Getenv("LINE_CHANNEL_ACCESS_TOKEN"))

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("LINE API error: %s", string(body))
	}
	return nil
}

// ===== LIFFèªè¨¼é–¢é€£ã®é–¢æ•° =====

// LIFFã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ¤œè¨¼ã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’å–å¾—
func verifyLIFFToken(accessToken string) (string, string, error) {
	// 1. LIFFã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼
	verifyURL := "https://api.line.me/oauth2/v2.1/verify?access_token=" + accessToken

	resp, err := http.Get(verifyURL)
	if err != nil {
		return "", "", fmt.Errorf("token verification failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return "", "", fmt.Errorf("invalid token: %s", string(body))
	}

	// 2. ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±ã‚’å–å¾—
	profileURL := "https://api.line.me/v2/profile"
	req, _ := http.NewRequest("GET", profileURL, nil)
	req.Header.Set("Authorization", "Bearer "+accessToken)

	profileResp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", "", fmt.Errorf("profile fetch failed: %w", err)
	}
	defer profileResp.Body.Close()

	if profileResp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(profileResp.Body)
		return "", "", fmt.Errorf("failed to get profile: %s", string(body))
	}

	var profile struct {
		UserID      string `json:"userId"`
		DisplayName string `json:"displayName"`
	}

	if err := json.NewDecoder(profileResp.Body).Decode(&profile); err != nil {
		return "", "", fmt.Errorf("failed to decode profile: %w", err)
	}

	return profile.UserID, profile.DisplayName, nil
}

// HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã‚‰LIFFãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ¤œè¨¼ã—ã€userIDã‚’å–å¾—
func authenticateRequest(r *http.Request) (string, string, error) {
	// Authorizationãƒ˜ãƒƒãƒ€ãƒ¼ã‹ã‚‰ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
	authHeader := r.Header.Get("Authorization")
	if authHeader == "" {
		return "", "", fmt.Errorf("authorization header is missing")
	}

	// "Bearer "ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’å‰Šé™¤
	token := strings.TrimPrefix(authHeader, "Bearer ")
	if token == authHeader {
		return "", "", fmt.Errorf("invalid authorization header format")
	}

	// LIFFãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ¤œè¨¼
	userID, displayName, err := verifyLIFFToken(token)
	if err != nil {
		return "", "", err
	}

	return userID, displayName, nil
}

// ã‚µãƒ‹ã‚¿ã‚¤ã‚ºã‚’ã™ã‚‹é–¢æ•°
func sanitizeInput(input string) string {
	sanitized := html.EscapeString(input)
	sanitized = strings.TrimSpace(sanitized)

	return sanitized
}

// Webhook: LINEã‹ã‚‰ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡
func handleWebhook(w http.ResponseWriter, r *http.Request) {
	// ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã‚’èª­ã¿å–ã£ã¦ãƒ­ã‚°å‡ºåŠ›
	bodyBytes, _ := io.ReadAll(r.Body)
	log.Printf("Webhookå—ä¿¡: %s", string(bodyBytes))

	// ãƒœãƒ‡ã‚£ã‚’å†åº¦ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹
	r.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))

	var req WebhookRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Printf("Webhookãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: %v", err)
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	log.Printf("ã‚¤ãƒ™ãƒ³ãƒˆæ•°: %d", len(req.Events))

	for _, event := range req.Events {
		log.Printf("ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—: %s", event.Type)

		if event.Type == "message" && event.Message.Type == "text" {
			// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä¿å­˜
			messages = append(messages, ReceivedMessage{
				Timestamp: time.Now(),
				UserID:    event.Source.UserID,
				Text:      event.Message.Text,
			})
			log.Printf("å—ä¿¡: %s (UserID: %s)", event.Message.Text, event.Source.UserID)

			// handleMessageé–¢æ•°ã‚’åˆ©ç”¨
			replyText := handleMessage(event.Source.UserID, event.Message.Text)
			if err := ReplyMessage(event.ReplyToken, replyText); err != nil {
				log.Printf("è¿”ä¿¡ã‚¨ãƒ©ãƒ¼: %v", err)
			} else {
				log.Printf("è¿”ä¿¡æˆåŠŸ: %s", replyText)
			}
		}
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "ok"})
}

// Web â†’ LINEé€ä¿¡
func handleSend(w http.ResponseWriter, r *http.Request) {
	var req struct {
		UserID  string `json:"userId"`
		Message string `json:"message"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Printf("JSONãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: %v", err)
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	if req.UserID == "" {
		log.Printf("ã‚¨ãƒ©ãƒ¼: User IDãŒç©ºã§ã™")
		http.Error(w, "User ID is required", http.StatusBadRequest)
		return
	}

	if req.Message == "" {
		log.Printf("ã‚¨ãƒ©ãƒ¼: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒç©ºã§ã™")
		http.Error(w, "Message is required", http.StatusBadRequest)
		return
	}

	log.Printf("é€ä¿¡è©¦è¡Œ: UserID=%s, Message=%s", req.UserID, req.Message)

	if err := PushMessage(req.UserID, req.Message); err != nil {
		log.Printf("é€ä¿¡ã‚¨ãƒ©ãƒ¼: %v", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	log.Printf("é€ä¿¡æˆåŠŸ: %s â†’ %s", req.Message, req.UserID)
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "ok"})
}

// å—ä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä¸€è¦§å–å¾—
func handleAllMessages(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(messages)
}

// ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§å–å¾—
func handleGetUsers(w http.ResponseWriter, r *http.Request) {
	rows, err := db.Query(`
		SELECT user_id, name, circle, step
		FROM users
		ORDER BY updated_at DESC
	`)
	if err != nil {
		log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼: %v", err)
		http.Error(w, "Failed to get users", http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	var userList []User
	for rows.Next() {
		var user User
		if err := rows.Scan(&user.UserID, &user.Name, &user.Circle, &user.Step); err != nil {
			log.Printf("ã‚¹ã‚­ãƒ£ãƒ³ã‚¨ãƒ©ãƒ¼: %v", err)
			continue
		}
		userList = append(userList, user)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(userList)
}

// ===== LIFFç”¨APIãƒãƒ³ãƒ‰ãƒ©ãƒ¼ =====

// ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ç™»éŒ²ï¼ˆLIFFèªè¨¼ä»˜ãï¼‰
func handleRegisterUser(w http.ResponseWriter, r *http.Request) {
	// LIFFãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ¤œè¨¼ã—ã¦userIDã‚’å–å¾—
	userID, displayName, err := authenticateRequest(r)
	if err != nil {
		log.Printf("èªè¨¼ã‚¨ãƒ©ãƒ¼: %v", err)
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	// ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã‚’èª­ã¿å–ã‚Š
	var req struct {
		Circle string `json:"circle"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Printf("JSONãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: %v", err)
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	circle := sanitizeInput(req.Circle)
	if circle == "" {
		http.Error(w, "Circle is required", http.StatusBadRequest)
		return
	}

	// æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
	existingUser, err := getUser(userID)
	if err != nil {
		log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	if existingUser != nil {
		// æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å ´åˆã¯æ›´æ–°
		existingUser.Name = displayName
		existingUser.Circle = circle
		existingUser.Step = 3 // ç™»éŒ²å®Œäº†
		if err := updateUser(existingUser); err != nil {
			log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°ã‚¨ãƒ©ãƒ¼: %v", err)
			http.Error(w, "Failed to update user", http.StatusInternalServerError)
			return
		}
		log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°æˆåŠŸ: %s (%s)", displayName, userID)
	} else {
		// æ–°è¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å ´åˆã¯ä½œæˆ
		newUser := &User{
			UserID: userID,
			Name:   displayName,
			Circle: circle,
			Step:   3, // ç™»éŒ²å®Œäº†
		}
		if err := saveUser(newUser); err != nil {
			log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¿å­˜ã‚¨ãƒ©ãƒ¼: %v", err)
			http.Error(w, "Failed to save user", http.StatusInternalServerError)
			return
		}
		log.Printf("æ–°è¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²æˆåŠŸ: %s (%s)", displayName, userID)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"status":      "ok",
		"userId":      userID,
		"displayName": displayName,
		"circle":      circle,
	})
}

// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ï¼ˆLIFFèªè¨¼ä»˜ãï¼‰
func handleLIFFMessage(w http.ResponseWriter, r *http.Request) {
	// LIFFãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ¤œè¨¼ã—ã¦userIDã‚’å–å¾—
	userID, _, err := authenticateRequest(r)
	if err != nil {
		log.Printf("èªè¨¼ã‚¨ãƒ©ãƒ¼: %v", err)
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	// ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã‚’èª­ã¿å–ã‚Š
	var req struct {
		Message string `json:"message"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Printf("JSONãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: %v", err)
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	message := sanitizeInput(req.Message)
	if message == "" {
		http.Error(w, "Message is required", http.StatusBadRequest)
		return
	}

	// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡¦ç†
	replyText := handleMessage(userID, message)

	// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’DBã«ä¿å­˜
	if err := saveMessage(userID, message); err != nil {
		log.Printf("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä¿å­˜ã‚¨ãƒ©ãƒ¼: %v", err)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"status": "ok",
		"reply":  replyText,
	})
}

// ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±å–å¾—ï¼ˆLIFFèªè¨¼ä»˜ãï¼‰
func handleGetMyInfo(w http.ResponseWriter, r *http.Request) {
	// LIFFãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ¤œè¨¼ã—ã¦userIDã‚’å–å¾—
	userID, displayName, err := authenticateRequest(r)
	if err != nil {
		log.Printf("èªè¨¼ã‚¨ãƒ©ãƒ¼: %v", err)
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	// DBã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—
	user, err := getUser(userID)
	if err != nil {
		log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	if user == nil {
		// æœªç™»éŒ²ãƒ¦ãƒ¼ã‚¶ãƒ¼
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"userId":      userID,
			"displayName": displayName,
			"registered":  false,
		})
		return
	}

	// ç™»éŒ²æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"userId":      user.UserID,
		"name":        user.Name,
		"displayName": displayName,
		"circle":      user.Circle,
		"registered":  true,
		"step":        user.Step,
	})
}

// ===== å‰²ã‚Šå‹˜ãƒ•ãƒ­ãƒ¼å‡¦ç†é–¢æ•° =====

// ç™»éŒ²æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
func handleRegisteredUserMessage(user *User, message string) string {
	// å‰²ã‚Šå‹˜ãƒ•ãƒ­ãƒ¼ä¸­ã®å ´åˆ
	if user.SplitEventStep > 0 {
		return handleSplitEventFlow(user, message)
	}

	// æ‰¿èªãƒ•ãƒ­ãƒ¼ä¸­ã®å ´åˆ
	if user.ApprovalStep > 0 {
		return handleApprovalFlow(user, message)
	}

	// ã‚³ãƒãƒ³ãƒ‰å‡¦ç†
	switch message {
	case "å‰²ã‚Šå‹˜":
		return startSplitEvent(user)
	case "æ”¯æ‰•ã„ã¾ã—ãŸ":
		return handlePaymentReport(user)
	case "çŠ¶æ³ç¢ºèª":
		return handleStatusCheck(user)
	case "æ‰¿èª":
		return startApproval(user)
	default:
		return "ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§:\nãƒ»å‰²ã‚Šå‹˜\nãƒ»æ”¯æ‰•ã„ã¾ã—ãŸ\nãƒ»çŠ¶æ³ç¢ºèª\nãƒ»æ‰¿èª"
	}
}

// å‰²ã‚Šå‹˜ã‚¤ãƒ™ãƒ³ãƒˆä½œæˆé–‹å§‹
func startSplitEvent(user *User) string {
	user.SplitEventStep = 1
	if err := updateUser(user); err != nil {
		log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°ã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
	}
	return "å‰²ã‚Šå‹˜ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã™ï¼\nã‚¤ãƒ™ãƒ³ãƒˆåã‚’æ•™ãˆã¦ãã ã•ã„ï¼ˆä¾‹: æ–°æ­“é£²ã¿ä¼šï¼‰"
}

// å‰²ã‚Šå‹˜ãƒ•ãƒ­ãƒ¼å‡¦ç†
func handleSplitEventFlow(user *User, message string) string {
	switch user.SplitEventStep {
	case 1:
		// ã‚¤ãƒ™ãƒ³ãƒˆåå…¥åŠ›
		return handleEventNameInput(user, message)
	case 2:
		// é‡‘é¡å…¥åŠ›
		return handleAmountInput(user, message)
	case 3:
		// å‚åŠ è€…é¸æŠ
		return handleParticipantSelection(user, message)
	default:
		user.SplitEventStep = 0
		updateUser(user)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚æœ€åˆã‹ã‚‰ã‚„ã‚Šç›´ã—ã¦ãã ã•ã„ã€‚"
	}
}

// ã‚¤ãƒ™ãƒ³ãƒˆåå…¥åŠ›å‡¦ç†
func handleEventNameInput(user *User, eventName string) string {
	// ä»®ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆï¼ˆé‡‘é¡ã¯å¾Œã§æ›´æ–°ï¼‰
	eventID, err := createEvent(user.UserID, eventName, user.Circle, 0, 0)
	if err != nil {
		log.Printf("ã‚¤ãƒ™ãƒ³ãƒˆä½œæˆã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
	}

	user.TempEventID = eventID
	user.SplitEventStep = 2
	if err := updateUser(user); err != nil {
		log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°ã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
	}

	return "åˆè¨ˆé‡‘é¡ã‚’æ•™ãˆã¦ãã ã•ã„ï¼ˆæ•°å­—ã®ã¿ã€ä¾‹: 15000ï¼‰"
}

// é‡‘é¡å…¥åŠ›å‡¦ç†
func handleAmountInput(user *User, message string) string {
	var totalAmount int
	if _, err := fmt.Sscanf(message, "%d", &totalAmount); err != nil || totalAmount <= 0 {
		return "æ­£ã—ã„é‡‘é¡ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆæ•°å­—ã®ã¿ï¼‰"
	}

	// ã‚¤ãƒ™ãƒ³ãƒˆæƒ…å ±ã‚’å–å¾—ã—ã¦æ›´æ–°
	event, err := getEvent(user.TempEventID)
	if err != nil || event == nil {
		log.Printf("ã‚¤ãƒ™ãƒ³ãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚æœ€åˆã‹ã‚‰ã‚„ã‚Šç›´ã—ã¦ãã ã•ã„ã€‚"
	}

	// ä¸€æ—¦splitAmountã¯0ã§ä¿å­˜ï¼ˆå‚åŠ è€…æ•°ãŒç¢ºå®šã—ã¦ã„ãªã„ãŸã‚ï¼‰
	_, err = db.Exec(`
		UPDATE events
		SET total_amount = $2
		WHERE id = $1
	`, user.TempEventID, totalAmount)

	if err != nil {
		log.Printf("ã‚¤ãƒ™ãƒ³ãƒˆæ›´æ–°ã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
	}

	user.SplitEventStep = 3
	if err := updateUser(user); err != nil {
		log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°ã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
	}

	// ã‚µãƒ¼ã‚¯ãƒ«ã®ãƒ¡ãƒ³ãƒãƒ¼ä¸€è¦§ã‚’å–å¾—
	members, err := getUsersByCircle(user.Circle)
	if err != nil {
		log.Printf("ãƒ¡ãƒ³ãƒãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
	}

	if len(members) == 0 {
		return "ã‚µãƒ¼ã‚¯ãƒ«ãƒ¡ãƒ³ãƒãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"
	}

	// ãƒ¡ãƒ³ãƒãƒ¼ä¸€è¦§ã‚’è¡¨ç¤ºï¼ˆè‡ªåˆ†ä»¥å¤–ï¼‰
	var memberList strings.Builder
	memberList.WriteString(fmt.Sprintf("äº†è§£ã—ã¾ã—ãŸï¼\nã‚¤ãƒ™ãƒ³ãƒˆå: %s\nåˆè¨ˆé‡‘é¡: %så††\n\n", event.EventName, formatAmount(totalAmount)))
	memberList.WriteString(fmt.Sprintf("æ¬¡ã«å‚åŠ è€…ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚\nåŒã˜ã‚µãƒ¼ã‚¯ãƒ«ï¼ˆ%sï¼‰ã®ãƒ¡ãƒ³ãƒãƒ¼:\n", user.Circle))

	memberIndex := 1
	for _, member := range members {
		if member.UserID != user.UserID {
			memberList.WriteString(fmt.Sprintf("%d. %s\n", memberIndex, member.Name))
			memberIndex++
		}
	}

	memberList.WriteString("\nç•ªå·ã‚’ã‚¹ãƒšãƒ¼ã‚¹åŒºåˆ‡ã‚Šã§é€ã£ã¦ãã ã•ã„ï¼ˆä¾‹: 1 2 3ï¼‰\nã€Œç¢ºå®šã€ã¨é€ä¿¡ã™ã‚‹ã¨ä¼šè¨ˆã®ã¿ã§ç¢ºå®šã—ã¾ã™")

	return memberList.String()
}

// å‚åŠ è€…é¸æŠå‡¦ç†
func handleParticipantSelection(user *User, message string) string {
	event, err := getEvent(user.TempEventID)
	if err != nil || event == nil {
		log.Printf("ã‚¤ãƒ™ãƒ³ãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚æœ€åˆã‹ã‚‰ã‚„ã‚Šç›´ã—ã¦ãã ã•ã„ã€‚"
	}

	// ã‚µãƒ¼ã‚¯ãƒ«ãƒ¡ãƒ³ãƒãƒ¼ã‚’å–å¾—
	members, err := getUsersByCircle(user.Circle)
	if err != nil {
		log.Printf("ãƒ¡ãƒ³ãƒãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
	}

	// è‡ªåˆ†ä»¥å¤–ã®ãƒ¡ãƒ³ãƒãƒ¼ã‚’ãƒªã‚¹ãƒˆåŒ–
	var otherMembers []User
	for _, member := range members {
		if member.UserID != user.UserID {
			otherMembers = append(otherMembers, member)
		}
	}

	var selectedMembers []User

	// ã€Œç¢ºå®šã€ã®å ´åˆã¯ä¼šè¨ˆã®ã¿
	if message != "ç¢ºå®š" {
		// ç•ªå·ã‚’è§£æ
		numbers := strings.Fields(message)
		for _, numStr := range numbers {
			var num int
			if _, err := fmt.Sscanf(numStr, "%d", &num); err == nil {
				if num > 0 && num <= len(otherMembers) {
					selectedMembers = append(selectedMembers, otherMembers[num-1])
				}
			}
		}

		if len(selectedMembers) == 0 {
			return "æ­£ã—ã„ç•ªå·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¾‹: 1 2 3ï¼‰\nã¾ãŸã¯ã€Œç¢ºå®šã€ã¨é€ä¿¡ã—ã¦ãã ã•ã„"
		}
	}

	// ä¼šè¨ˆæ‹…å½“è€…ã‚’å‚åŠ è€…ã«è¿½åŠ 
	if err := addParticipant(user.TempEventID, user.UserID, user.Name); err != nil {
		log.Printf("å‚åŠ è€…è¿½åŠ ã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
	}

	// é¸æŠã•ã‚ŒãŸãƒ¡ãƒ³ãƒãƒ¼ã‚’å‚åŠ è€…ã«è¿½åŠ 
	for _, member := range selectedMembers {
		if err := addParticipant(user.TempEventID, member.UserID, member.Name); err != nil {
			log.Printf("å‚åŠ è€…è¿½åŠ ã‚¨ãƒ©ãƒ¼: %v", err)
		}
	}

	// å‚åŠ è€…æ•°ã«åŸºã¥ã„ã¦1äººã‚ãŸã‚Šã®é‡‘é¡ã‚’è¨ˆç®—
	totalParticipants := len(selectedMembers) + 1 // +1ã¯ä¼šè¨ˆæ‹…å½“è€…
	splitAmount := event.TotalAmount / totalParticipants

	// ã‚¤ãƒ™ãƒ³ãƒˆæƒ…å ±ã‚’æ›´æ–°
	_, err = db.Exec(`
		UPDATE events
		SET split_amount = $2, status = 'confirmed'
		WHERE id = $1
	`, user.TempEventID, splitAmount)

	if err != nil {
		log.Printf("ã‚¤ãƒ™ãƒ³ãƒˆæ›´æ–°ã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
	}

	// ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’ãƒªã‚»ãƒƒãƒˆ
	user.SplitEventStep = 0
	user.TempEventID = 0
	if err := updateUser(user); err != nil {
		log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°ã‚¨ãƒ©ãƒ¼: %v", err)
	}

	// å‚åŠ è€…å…¨å“¡ã«é€šçŸ¥
	go notifyParticipants(event.ID, user.Name)

	// ç¢ºèªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
	var response strings.Builder
	response.WriteString("ä»¥ä¸‹ã®ãƒ¡ãƒ³ãƒãƒ¼ã‚’é¸æŠã—ã¾ã—ãŸ:\n")
	for _, member := range selectedMembers {
		response.WriteString(fmt.Sprintf("ãƒ»%s\n", member.Name))
	}
	response.WriteString(fmt.Sprintf("ãƒ»%sï¼ˆä¼šè¨ˆï¼‰\n\n", user.Name))
	response.WriteString(fmt.Sprintf("åˆè¨ˆ%däººã§%så†† â†’ 1äººã‚ãŸã‚Š %så††\n\n", totalParticipants, formatAmount(event.TotalAmount), formatAmount(splitAmount)))
	response.WriteString("å‰²ã‚Šå‹˜ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸï¼\nå‚åŠ è€…å…¨å“¡ã«é€šçŸ¥ã‚’é€ä¿¡ã—ã¾ã—ãŸã€‚\n\n")
	response.WriteString("ã€ŒçŠ¶æ³ç¢ºèªã€ã§æ”¯æ‰•ã„çŠ¶æ³ã‚’ç¢ºèªã§ãã¾ã™ã€‚")

	return response.String()
}

// æ”¯æ‰•ã„å ±å‘Šå‡¦ç†
func handlePaymentReport(user *User) string {
	// ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æœªæ‰•ã„ã‚¤ãƒ™ãƒ³ãƒˆã‚’å–å¾—
	event, err := getUserActiveEvent(user.UserID)
	if err != nil {
		log.Printf("ã‚¤ãƒ™ãƒ³ãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
	}

	if event == nil {
		return "æœªæ‰•ã„ã®ã‚¤ãƒ™ãƒ³ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"
	}

	// æ”¯æ‰•ã„å ±å‘Šã‚’è¨˜éŒ²ï¼ˆæ‰¿èªå¾…ã¡çŠ¶æ…‹ï¼‰
	if err := markAsReported(event.ID, user.UserID); err != nil {
		log.Printf("æ”¯æ‰•ã„å ±å‘Šã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
	}

	// ä¼šè¨ˆæ‹…å½“è€…ã«é€šçŸ¥
	go func() {
		organizerName := ""
		organizer, err := getUser(event.OrganizerID)
		if err == nil && organizer != nil {
			organizerName = organizer.Name
		}

		notifyText := fmt.Sprintf("%sã•ã‚“ãŒæ”¯æ‰•ã„å ±å‘Šã‚’ã—ã¾ã—ãŸã€‚\nï¼ˆ%s: %så††ï¼‰\n\nã€Œæ‰¿èªã€ã‚³ãƒãƒ³ãƒ‰ã§æ”¯æ‰•ã„ã‚’æ‰¿èªã—ã¦ãã ã•ã„ã€‚\nã€ŒçŠ¶æ³ç¢ºèªã€ã§è©³ç´°ã‚’ç¢ºèªã§ãã¾ã™ã€‚", user.Name, event.EventName, formatAmount(event.SplitAmount))
		PushMessage(event.OrganizerID, notifyText)
		log.Printf("ä¼šè¨ˆæ‹…å½“è€…ï¼ˆ%sï¼‰ã«é€šçŸ¥: %s", organizerName, notifyText)
	}()

	return fmt.Sprintf("æ”¯æ‰•ã„å ±å‘Šã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸã€‚\nï¼ˆ%s: %så††ï¼‰\n\nä¼šè¨ˆæ‹…å½“è€…ã®ç¢ºèªã‚’ãŠå¾…ã¡ãã ã•ã„ã€‚", event.EventName, formatAmount(event.SplitAmount))
}

// æ”¯æ‰•ã„çŠ¶æ³ç¢ºèª
func handleStatusCheck(user *User) string {
	// ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä¼šè¨ˆã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’å–å¾—
	rows, err := db.Query(`
		SELECT id, event_name, total_amount, split_amount, status
		FROM events
		WHERE organizer_id = $1
		ORDER BY created_at DESC
		LIMIT 5
	`, user.UserID)

	if err != nil {
		log.Printf("ã‚¤ãƒ™ãƒ³ãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
	}
	defer rows.Close()

	var response strings.Builder
	response.WriteString("ã€æ”¯æ‰•ã„çŠ¶æ³ã€‘\n\n")

	hasEvents := false
	for rows.Next() {
		hasEvents = true
		var eventID int
		var eventName string
		var totalAmount, splitAmount int
		var status string

		if err := rows.Scan(&eventID, &eventName, &totalAmount, &splitAmount, &status); err != nil {
			continue
		}

		response.WriteString(fmt.Sprintf("â–¼ %s\n", eventName))
		response.WriteString(fmt.Sprintf("åˆè¨ˆ: %så†† (1äºº: %så††)\n", formatAmount(totalAmount), formatAmount(splitAmount)))

		// å‚åŠ è€…ã®æ”¯æ‰•ã„çŠ¶æ³ã‚’å–å¾—
		participants, err := getParticipants(eventID)
		if err != nil {
			continue
		}

		// çŠ¶æ…‹ã”ã¨ã«åˆ†é¡
		var paidList, reportedList, unpaidList []Participant
		for _, p := range participants {
			if p.Paid {
				paidList = append(paidList, p)
			} else if p.ReportedAt != nil {
				reportedList = append(reportedList, p)
			} else {
				unpaidList = append(unpaidList, p)
			}
		}

		// æ”¯æ‰•ã„æ¸ˆã¿
		if len(paidList) > 0 {
			response.WriteString(fmt.Sprintf("\nâœ… æ”¯æ‰•ã„æ¸ˆã¿ï¼ˆ%däººï¼‰\n", len(paidList)))
			for _, p := range paidList {
				response.WriteString(fmt.Sprintf("   %s: %så††\n", p.UserName, formatAmount(splitAmount)))
			}
		}

		// å ±å‘Šæ¸ˆã¿ï¼ˆæœªæ‰¿èªï¼‰
		if len(reportedList) > 0 {
			response.WriteString(fmt.Sprintf("\nğŸ“‹ å ±å‘Šæ¸ˆã¿ï¼ˆæœªæ‰¿èª: %däººï¼‰\n", len(reportedList)))
			for _, p := range reportedList {
				response.WriteString(fmt.Sprintf("   %s: %så††\n", p.UserName, formatAmount(splitAmount)))
			}
		}

		// æœªæ‰•ã„
		if len(unpaidList) > 0 {
			response.WriteString(fmt.Sprintf("\nâŒ æœªæ‰•ã„ï¼ˆ%däººï¼‰\n", len(unpaidList)))
			for _, p := range unpaidList {
				response.WriteString(fmt.Sprintf("   %s: %så††\n", p.UserName, formatAmount(splitAmount)))
			}
		}

		response.WriteString("\n")
	}

	if !hasEvents {
		response.WriteString("ã‚¤ãƒ™ãƒ³ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚\nã€Œå‰²ã‚Šå‹˜ã€ã¨é€ä¿¡ã—ã¦æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã§ãã¾ã™ã€‚")
	} else {
		response.WriteString("ã€Œæ‰¿èªã€ã§å ±å‘Šæ¸ˆã¿ã®æ”¯æ‰•ã„ã‚’æ‰¿èªã§ãã¾ã™ã€‚")
	}

	return response.String()
}

// å‚åŠ è€…å…¨å“¡ã«é€šçŸ¥
func notifyParticipants(eventID int, organizerName string) {
	event, err := getEvent(eventID)
	if err != nil || event == nil {
		log.Printf("é€šçŸ¥ã‚¨ãƒ©ãƒ¼: ã‚¤ãƒ™ãƒ³ãƒˆå–å¾—å¤±æ•—")
		return
	}

	participants, err := getParticipants(eventID)
	if err != nil {
		log.Printf("é€šçŸ¥ã‚¨ãƒ©ãƒ¼: å‚åŠ è€…å–å¾—å¤±æ•—")
		return
	}

	for _, p := range participants {
		// ä¼šè¨ˆæ‹…å½“è€…ã«ã¯é€šçŸ¥ã—ãªã„
		if p.UserID == event.OrganizerID {
			continue
		}

		notifyText := fmt.Sprintf("ã€å‰²ã‚Šå‹˜ã®ãŠçŸ¥ã‚‰ã›ã€‘\n%sã•ã‚“ãŒå‰²ã‚Šå‹˜ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸã€‚\n\nã‚¤ãƒ™ãƒ³ãƒˆ: %s\nã‚ãªãŸã®æ”¯æ‰•é¡: %så††\næ”¯æ‰•å…ˆ: %s\n\næ”¯æ‰•ã„ãŒå®Œäº†ã—ãŸã‚‰ã€Œæ”¯æ‰•ã„ã¾ã—ãŸã€ã¨é€ä¿¡ã—ã¦ãã ã•ã„ã€‚",
			organizerName, event.EventName, formatAmount(event.SplitAmount), organizerName)

		if err := PushMessage(p.UserID, notifyText); err != nil {
			log.Printf("é€šçŸ¥ã‚¨ãƒ©ãƒ¼ (%s): %v", p.UserName, err)
		} else {
			log.Printf("é€šçŸ¥æˆåŠŸ: %s", p.UserName)
		}
	}
}

// é‡‘é¡ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šï¼‰
func formatAmount(amount int) string {
	str := fmt.Sprintf("%d", amount)
	if len(str) <= 3 {
		return str
	}

	var result strings.Builder
	for i, c := range str {
		if i > 0 && (len(str)-i)%3 == 0 {
			result.WriteRune(',')
		}
		result.WriteRune(c)
	}
	return result.String()
}

// ===== æ‰¿èªãƒ•ãƒ­ãƒ¼å‡¦ç†é–¢æ•° =====

// æ‰¿èªãƒ•ãƒ­ãƒ¼é–‹å§‹
func startApproval(user *User) string {
	// å ±å‘Šæ¸ˆã¿ï¼ˆæœªæ‰¿èªï¼‰ã®å‚åŠ è€…ãŒã„ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã‚’å–å¾—
	rows, err := db.Query(`
		SELECT DISTINCT e.id, e.event_name
		FROM events e
		JOIN event_participants p ON e.id = p.event_id
		WHERE e.organizer_id = $1 AND e.status = 'confirmed'
		  AND p.reported_at IS NOT NULL AND p.paid = FALSE
		ORDER BY e.created_at DESC
	`, user.UserID)

	if err != nil {
		log.Printf("ã‚¤ãƒ™ãƒ³ãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
	}
	defer rows.Close()

	var events []struct {
		ID   int
		Name string
	}

	for rows.Next() {
		var e struct {
			ID   int
			Name string
		}
		if err := rows.Scan(&e.ID, &e.Name); err != nil {
			continue
		}
		events = append(events, e)
	}

	if len(events) == 0 {
		return "æ‰¿èªå¾…ã¡ã®æ”¯æ‰•ã„å ±å‘Šã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"
	}

	// 1ã¤ã®ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆã¯ç›´æ¥æ‰¿èªãƒ•ãƒ­ãƒ¼ã¸
	if len(events) == 1 {
		return showApprovalList(user, events[0].ID)
	}

	// è¤‡æ•°ã®ã‚¤ãƒ™ãƒ³ãƒˆãŒã‚ã‚‹å ´åˆã¯ã‚¤ãƒ™ãƒ³ãƒˆé¸æŠ
	var response strings.Builder
	response.WriteString("æ‰¿èªå¯¾è±¡ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„:\n\n")
	for i, e := range events {
		response.WriteString(fmt.Sprintf("%d. %s\n", i+1, e.Name))
	}
	response.WriteString("\nç•ªå·ã‚’é€ä¿¡ã—ã¦ãã ã•ã„")

	// ä¸€æ—¦ã€æœ€åˆã®ã‚¤ãƒ™ãƒ³ãƒˆã§æ‰¿èªãƒ•ãƒ­ãƒ¼ã‚’é–‹å§‹ï¼ˆç°¡ç•¥åŒ–ï¼‰
	return showApprovalList(user, events[0].ID)
}

// æ‰¿èªãƒªã‚¹ãƒˆã‚’è¡¨ç¤º
func showApprovalList(user *User, eventID int) string {
	event, err := getEvent(eventID)
	if err != nil || event == nil {
		return "ã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"
	}

	participants, err := getParticipants(eventID)
	if err != nil {
		return "å‚åŠ è€…æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"
	}

	// å ±å‘Šæ¸ˆã¿ï¼ˆæœªæ‰¿èªï¼‰ã®å‚åŠ è€…ã‚’ãƒªã‚¹ãƒˆåŒ–
	var reportedList []Participant
	for _, p := range participants {
		if !p.Paid && p.ReportedAt != nil {
			reportedList = append(reportedList, p)
		}
	}

	if len(reportedList) == 0 {
		return "æ‰¿èªå¾…ã¡ã®æ”¯æ‰•ã„å ±å‘Šã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"
	}

	var response strings.Builder
	response.WriteString(fmt.Sprintf("ã€%sã€‘\n", event.EventName))
	response.WriteString("å ±å‘Šæ¸ˆã¿ã®æ”¯æ‰•ã„ã‚’æ‰¿èªã—ã¾ã™ã€‚\n\n")

	for i, p := range reportedList {
		response.WriteString(fmt.Sprintf("%d. %s (%så††)\n", i+1, p.UserName, formatAmount(event.SplitAmount)))
	}

	response.WriteString("\næ‰¿èªã™ã‚‹ç•ªå·ã‚’é€ã£ã¦ãã ã•ã„ï¼ˆä¾‹: 1 2ï¼‰\n")
	response.WriteString("ã€Œã™ã¹ã¦ã€ã§å…¨å“¡æ‰¿èª\n")
	response.WriteString("ã€Œã‚­ãƒ£ãƒ³ã‚»ãƒ«ã€ã§ä¸­æ­¢")

	// æ‰¿èªãƒ•ãƒ­ãƒ¼ã‚’é–‹å§‹
	user.ApprovalStep = 1
	user.ApprovalEventID = eventID
	if err := updateUser(user); err != nil {
		log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°ã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
	}

	return response.String()
}

// æ‰¿èªãƒ•ãƒ­ãƒ¼å‡¦ç†
func handleApprovalFlow(user *User, message string) string {
	// ã‚­ãƒ£ãƒ³ã‚»ãƒ«
	if message == "ã‚­ãƒ£ãƒ³ã‚»ãƒ«" {
		user.ApprovalStep = 0
		user.ApprovalEventID = 0
		if err := updateUser(user); err != nil {
			log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°ã‚¨ãƒ©ãƒ¼: %v", err)
		}
		return "æ‰¿èªã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚"
	}

	event, err := getEvent(user.ApprovalEventID)
	if err != nil || event == nil {
		user.ApprovalStep = 0
		user.ApprovalEventID = 0
		updateUser(user)
		return "ã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"
	}

	// ğŸ”’ æ‰¿èªæ¨©é™ãƒã‚§ãƒƒã‚¯ï¼šæ‰¿èªè€…ãŒä¼šè¨ˆæ‹…å½“è€…ã‹ã©ã†ã‹ç¢ºèª
	if event.OrganizerID != user.UserID {
		user.ApprovalStep = 0
		user.ApprovalEventID = 0
		updateUser(user)
		return "ã‚¨ãƒ©ãƒ¼ï¼šã“ã®æ“ä½œã¯ä¼šè¨ˆæ‹…å½“è€…ã®ã¿å®Ÿè¡Œã§ãã¾ã™ã€‚"
	}

	participants, err := getParticipants(user.ApprovalEventID)
	if err != nil {
		return "å‚åŠ è€…æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"
	}

	// å ±å‘Šæ¸ˆã¿ï¼ˆæœªæ‰¿èªï¼‰ã®å‚åŠ è€…ã‚’ãƒªã‚¹ãƒˆåŒ–
	var reportedList []Participant
	for _, p := range participants {
		if !p.Paid && p.ReportedAt != nil {
			reportedList = append(reportedList, p)
		}
	}

	if len(reportedList) == 0 {
		user.ApprovalStep = 0
		user.ApprovalEventID = 0
		updateUser(user)
		return "æ‰¿èªå¾…ã¡ã®æ”¯æ‰•ã„å ±å‘Šã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"
	}

	var approvedList []Participant

	// ã€Œã™ã¹ã¦ã€ã®å ´åˆã¯å…¨å“¡æ‰¿èª
	if message == "ã™ã¹ã¦" {
		approvedList = reportedList
	} else {
		// ç•ªå·ã‚’è§£æ
		numbers := strings.Fields(message)
		for _, numStr := range numbers {
			var num int
			if _, err := fmt.Sscanf(numStr, "%d", &num); err == nil {
				if num > 0 && num <= len(reportedList) {
					approvedList = append(approvedList, reportedList[num-1])
				}
			}
		}

		if len(approvedList) == 0 {
			return "æ­£ã—ã„ç•ªå·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¾‹: 1 2ï¼‰\nã¾ãŸã¯ã€Œã™ã¹ã¦ã€ã€Œã‚­ãƒ£ãƒ³ã‚»ãƒ«ã€ã¨é€ä¿¡ã—ã¦ãã ã•ã„"
		}
	}

	// æ‰¿èªå‡¦ç†
	var approvedNames []string
	for _, p := range approvedList {
		if err := approvePayment(user.ApprovalEventID, p.UserID); err != nil {
			log.Printf("æ‰¿èªã‚¨ãƒ©ãƒ¼ (%s): %v", p.UserName, err)
		} else {
			approvedNames = append(approvedNames, p.UserName)

			// å‚åŠ è€…ã«é€šçŸ¥
			go func(userID, userName string) {
				notifyText := fmt.Sprintf("ã€æ”¯æ‰•ã„æ‰¿èªã€‘\n%sã•ã‚“ãŒæ”¯æ‰•ã„ã‚’æ‰¿èªã—ã¾ã—ãŸã€‚\n\nã‚¤ãƒ™ãƒ³ãƒˆ: %s\né‡‘é¡: %så††\n\nã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸï¼",
					user.Name, event.EventName, formatAmount(event.SplitAmount))
				PushMessage(userID, notifyText)
				log.Printf("æ‰¿èªé€šçŸ¥é€ä¿¡: %s", userName)
			}(p.UserID, p.UserName)
		}
	}

	// æ‰¿èªãƒ•ãƒ­ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
	user.ApprovalStep = 0
	user.ApprovalEventID = 0
	if err := updateUser(user); err != nil {
		log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°ã‚¨ãƒ©ãƒ¼: %v", err)
	}

	if len(approvedNames) == 0 {
		return "æ‰¿èªã«å¤±æ•—ã—ã¾ã—ãŸã€‚"
	}

	var response strings.Builder
	response.WriteString(fmt.Sprintf("%däººã®æ”¯æ‰•ã„ã‚’æ‰¿èªã—ã¾ã—ãŸã€‚\n\n", len(approvedNames)))
	for _, name := range approvedNames {
		response.WriteString(fmt.Sprintf("âœ… %s\n", name))
	}
	response.WriteString("\nå‚åŠ è€…ã«é€šçŸ¥ã‚’é€ä¿¡ã—ã¾ã—ãŸã€‚")

	return response.String()
}

func handleMessage(userID string, message string) string {
	message = sanitizeInput(message)

	if message == "" {
		return "ä¸­èº«ãŒãªã„ã§ã™"
	}

	// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’DBã«ä¿å­˜
	if err := saveMessage(userID, message); err != nil {
		log.Printf("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä¿å­˜ã‚¨ãƒ©ãƒ¼: %v", err)
	}

	// DBã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—
	user, err := getUser(userID)
	if err != nil {
		log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼: %v", err)
		return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚"
	}

	// æ–°è¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å ´åˆ
	if user == nil {
		newUser := &User{
			UserID: userID,
			Name:   "",
			Circle: "",
			Step:   1,
		}
		if err := saveUser(newUser); err != nil {
			log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¿å­˜ã‚¨ãƒ©ãƒ¼: %v", err)
			return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚"
		}
		return "åˆã‚ã¾ã—ã¦ï¼ãŠåå‰ã‚’æ•™ãˆã¦ãã ã•ã„ï¼"
	}

	// ç™»éŒ²æ®µéšã«å¿œã˜ã¦å¯¾å¿œã‚’å¤‰ãˆã‚‹
	switch user.Step {
	case 1:
		user.Name = message
		user.Step = 2
		if err := updateUser(user); err != nil {
			log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°ã‚¨ãƒ©ãƒ¼: %v", err)
			return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚"
		}
		return fmt.Sprintf("%sã•ã‚“ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼\næ‰€å±ã—ã¦ã„ã‚‹ã‚µãƒ¼ã‚¯ãƒ«åã‚’æ•™ãˆã¦ãã ã•ã„ï¼", user.Name)
	case 2:
		user.Circle = message
		user.Step = 3
		if err := updateUser(user); err != nil {
			log.Printf("ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°ã‚¨ãƒ©ãƒ¼: %v", err)
			return "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚"
		}
		return fmt.Sprintf("ç™»éŒ²å®Œäº†ã—ã¾ã—ãŸï¼\nåå‰: %s\nã‚µãƒ¼ã‚¯ãƒ«: %s\n\nã“ã‚Œã‹ã‚‰ CirclePay ã‚’ã”åˆ©ç”¨ã„ãŸã ã‘ã¾ã™ï¼", user.Name, user.Circle)
	case 3:
		// ç™»éŒ²å®Œäº†å¾Œã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
		return handleRegisteredUserMessage(user, message)
	default:
		return ""
	}
}

// é™çš„ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆSPAå¯¾å¿œï¼‰
func handleStaticFiles(w http.ResponseWriter, r *http.Request) {
	// é™çš„ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
	staticDir := "frontend/dist"

	// ãƒªã‚¯ã‚¨ã‚¹ãƒˆã•ã‚ŒãŸãƒ‘ã‚¹
	path := r.URL.Path
	if path == "/" {
		path = "/index.html"
	}

	// ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ§‹ç¯‰
	filePath := staticDir + path

	// ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		// ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯index.htmlã‚’è¿”ã™ï¼ˆSPAå¯¾å¿œï¼‰
		http.ServeFile(w, r, staticDir+"/index.html")
		return
	}

	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿”ã™
	http.ServeFile(w, r, filePath)
}

func main() {
	// .envãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
	if err := godotenv.Load(); err != nil {
		log.Println("Warning: .env file not found, using system environment variables")
	}

	if os.Getenv("LINE_CHANNEL_ACCESS_TOKEN") == "" {
		log.Fatal("LINE_CHANNEL_ACCESS_TOKEN is not set")
	}

	// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–
	if err := initDB(); err != nil {
		log.Fatal("Failed to initialize database: ", err)
	}
	defer db.Close()

	// ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ
	if err := createTables(); err != nil {
		log.Fatal("Failed to create tables: ", err)
	}

	// æ—¢å­˜ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆWebhookã€ç®¡ç†ç”»é¢ç”¨ï¼‰
	http.HandleFunc("/webhook", handleWebhook)
	http.HandleFunc("/send", handleSend)
	http.HandleFunc("/messages", handleAllMessages)
	http.HandleFunc("/api/users", handleGetUsers)

	// LIFFç”¨APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆèªè¨¼ä»˜ãï¼‰
	http.HandleFunc("/api/liff/register", handleRegisterUser)
	http.HandleFunc("/api/liff/message", handleLIFFMessage)
	http.HandleFunc("/api/liff/me", handleGetMyInfo)

	// é™çš„ãƒ•ã‚¡ã‚¤ãƒ«
	http.HandleFunc("/", handleStaticFiles)

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	log.Printf("Server starting on port %s...", port)
	log.Fatal(http.ListenAndServe(":"+port, nil))
}